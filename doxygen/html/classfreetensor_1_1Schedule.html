<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeTensor: freetensor::Schedule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeTensor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefreetensor.html">freetensor</a></li><li class="navelem"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfreetensor_1_1Schedule-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">freetensor::Schedule Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="schedule_8h_source.html">schedule.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acf8585443368254e352dbe9e6408978a"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">IDMap</a></td></tr>
<tr class="separator:acf8585443368254e352dbe9e6408978a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a84f1476fcab9676d4311a579c32a4416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a84f1476fcab9676d4311a579c32a4416">Schedule</a> ()=default</td></tr>
<tr class="separator:a84f1476fcab9676d4311a579c32a4416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cda3d04400a0c0a162eb5769e2d20d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a5cda3d04400a0c0a162eb5769e2d20d5">Schedule</a> (const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;<a class="el" href="classfreetensor_1_1Schedule.html#a406476c26709567e73b443121335f7f7">ast</a>, int <a class="el" href="classfreetensor_1_1Schedule.html#a0eb270dbcfd94ec971f672850d184c59">verbose</a>=0)</td></tr>
<tr class="separator:a5cda3d04400a0c0a162eb5769e2d20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2318d60c8c228271327668df47785fc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a2318d60c8c228271327668df47785fc7">Schedule</a> (const <a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a> &amp;<a class="el" href="classfreetensor_1_1Schedule.html#ad23d1f71efbc801f2cfa34ad8535ebaa">func</a>, int <a class="el" href="classfreetensor_1_1Schedule.html#a0eb270dbcfd94ec971f672850d184c59">verbose</a>=0)</td></tr>
<tr class="separator:a2318d60c8c228271327668df47785fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86c499bba4ac099f22c00233d7a17f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ac86c499bba4ac099f22c00233d7a17f4">Schedule</a> (const <a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> &amp;)=default</td></tr>
<tr class="separator:ac86c499bba4ac099f22c00233d7a17f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad805cbf90171357669445e969d69ebd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ad805cbf90171357669445e969d69ebd8">operator=</a> (const <a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> &amp;)=default</td></tr>
<tr class="separator:ad805cbf90171357669445e969d69ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29861fd233c49e64fa0df3ef76b9ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ad29861fd233c49e64fa0df3ef76b9ff0">fork</a> () const</td></tr>
<tr class="separator:ad29861fd233c49e64fa0df3ef76b9ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23d1f71efbc801f2cfa34ad8535ebaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ad23d1f71efbc801f2cfa34ad8535ebaa">func</a> () const</td></tr>
<tr class="separator:ad23d1f71efbc801f2cfa34ad8535ebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406476c26709567e73b443121335f7f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a406476c26709567e73b443121335f7f7">ast</a> () const</td></tr>
<tr class="separator:a406476c26709567e73b443121335f7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d66befe98d65de717c0400e32fbc6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacefreetensor.html#a3ade010f117f2ddf99e1c076eae94715">ScheduleLog</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ae89d66befe98d65de717c0400e32fbc6">logs</a> () const</td></tr>
<tr class="separator:ae89d66befe98d65de717c0400e32fbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb270dbcfd94ec971f672850d184c59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a0eb270dbcfd94ec971f672850d184c59">verbose</a> () const</td></tr>
<tr class="separator:a0eb270dbcfd94ec971f672850d184c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5574f50763b75ad856832a458b563f65"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5574f50763b75ad856832a458b563f65"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a5574f50763b75ad856832a458b563f65">findAll</a> (const T &amp;<a class="el" href="namespacefreetensor.html#a5997edb53e600a6645243d5d2684f129">filter</a>) const</td></tr>
<tr class="separator:a5574f50763b75ad856832a458b563f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8774a9abb8156dceb92789c8aec360"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e8774a9abb8156dceb92789c8aec360"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a6e8774a9abb8156dceb92789c8aec360">findAtLeastOne</a> (const T &amp;<a class="el" href="namespacefreetensor.html#a5997edb53e600a6645243d5d2684f129">filter</a>) const</td></tr>
<tr class="separator:a6e8774a9abb8156dceb92789c8aec360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9e820117a0bb7341541f7e338e1e73"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d9e820117a0bb7341541f7e338e1e73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a4d9e820117a0bb7341541f7e338e1e73">find</a> (const T &amp;<a class="el" href="namespacefreetensor.html#a5997edb53e600a6645243d5d2684f129">filter</a>) const</td></tr>
<tr class="separator:a4d9e820117a0bb7341541f7e338e1e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8d59c65897666a3380aa5bb887736"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a92a8d59c65897666a3380aa5bb887736">split</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;id, int factor=-1, int nparts=-1, int shift=0)</td></tr>
<tr class="separator:a92a8d59c65897666a3380aa5bb887736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7152785074bdd363a5eb0091819b9152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a7152785074bdd363a5eb0091819b9152">reorder</a> (const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;order)</td></tr>
<tr class="separator:a7152785074bdd363a5eb0091819b9152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a2b69d757e3277d357d76fc06c5c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1ID.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#aa1a2b69d757e3277d357d76fc06c5c82">merge</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop1, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop2)</td></tr>
<tr class="separator:aa1a2b69d757e3277d357d76fc06c5c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b7a57ec6518dc5c6cd53bc8d2b8cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a575b7a57ec6518dc5c6cd53bc8d2b8cc">permute</a> (const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;loopsId, const std::function&lt; std::vector&lt; <a class="el" href="namespacefreetensor.html#acfa6f07a5497b3d187fe112708aa335b">Expr</a> &gt;(std::vector&lt; <a class="el" href="namespacefreetensor.html#acfa6f07a5497b3d187fe112708aa335b">Expr</a> &gt;)&gt; &amp;transformFunc)</td></tr>
<tr class="separator:a575b7a57ec6518dc5c6cd53bc8d2b8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3a08f444cfd3d3561c216ac86d33fd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">IDMap</a>, <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">IDMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a4c3a08f444cfd3d3561c216ac86d33fd">fission</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop, <a class="el" href="namespacefreetensor.html#a2b0728b023b746c7fb73d4f24a6bb15e">FissionSide</a> side, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;splitter, bool allowEnlarge=true, const std::string &amp;suffix0=&quot;.0&quot;, const std::string &amp;suffix1=&quot;.1&quot;)</td></tr>
<tr class="separator:a4c3a08f444cfd3d3561c216ac86d33fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade01fd2d0d808e2e6f76ee11af33c33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ade01fd2d0d808e2e6f76ee11af33c33d">swap</a> (const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;order)</td></tr>
<tr class="separator:ade01fd2d0d808e2e6f76ee11af33c33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb236565d0d590d7f4ee357d7b06911d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#adb236565d0d590d7f4ee357d7b06911d">blend</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop)</td></tr>
<tr class="separator:adb236565d0d590d7f4ee357d7b06911d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb75fe9ab13e88589e3eeb6de82a854"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#adcb75fe9ab13e88589e3eeb6de82a854">cache</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;stmt, const std::string &amp;var, <a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a> mtype)</td></tr>
<tr class="separator:adcb75fe9ab13e88589e3eeb6de82a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c690de5bdcec52d0dbacf9d1b2a2d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a6e3c690de5bdcec52d0dbacf9d1b2a2d">cacheReduction</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;stmt, const std::string &amp;var, <a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a> mtype)</td></tr>
<tr class="separator:a6e3c690de5bdcec52d0dbacf9d1b2a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83689544088377af6145346f8046b9ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a83689544088377af6145346f8046b9ee">varSplit</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, int dim, <a class="el" href="namespacefreetensor.html#aa84a1eedb0880915c25c6ba5a2aa4db5">VarSplitMode</a> mode, int factor=-1, int nparts=-1)</td></tr>
<tr class="separator:a83689544088377af6145346f8046b9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afd2c54b5c306cea3ef02276278a638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a4afd2c54b5c306cea3ef02276278a638">varMerge</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, int dim)</td></tr>
<tr class="separator:a4afd2c54b5c306cea3ef02276278a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0527473deeef7e00524a5aa1887c974b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a0527473deeef7e00524a5aa1887c974b">varReorder</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, const std::vector&lt; int &gt; &amp;order)</td></tr>
<tr class="separator:a0527473deeef7e00524a5aa1887c974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8f42786f010644795cac660b690b61"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a6e8f42786f010644795cac660b690b61">moveTo</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;stmt, <a class="el" href="namespacefreetensor.html#ac490983b87e6acdba7919a1cf57245c3">MoveToSide</a> side, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;dst)</td></tr>
<tr class="separator:a6e8f42786f010644795cac660b690b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc2f98d42e75a3838eaa0166b802e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a9bfc2f98d42e75a3838eaa0166b802e2">inlining</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def)</td></tr>
<tr class="separator:a9bfc2f98d42e75a3838eaa0166b802e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed97de683ffe2a24b50c167cfc1f273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#afed97de683ffe2a24b50c167cfc1f273">parallelize</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop, const <a class="el" href="namespacefreetensor.html#a6d19bf2262d0cd0af3903283c9722088">ParallelScope</a> &amp;parallel, bool allowReduction=true)</td></tr>
<tr class="separator:afed97de683ffe2a24b50c167cfc1f273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae9bde8c67ec254ea7ea1542ef74660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a3ae9bde8c67ec254ea7ea1542ef74660">unroll</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop, bool immediate=false)</td></tr>
<tr class="separator:a3ae9bde8c67ec254ea7ea1542ef74660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d9ada77583888471a8378d400daf49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ac1d9ada77583888471a8378d400daf49">vectorize</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop)</td></tr>
<tr class="separator:ac1d9ada77583888471a8378d400daf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb3fd33acc0a8940fc36fe97a9a9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a5acb3fd33acc0a8940fc36fe97a9a9da">separateTail</a> (bool noDuplicateVarDefs=false)</td></tr>
<tr class="separator:a5acb3fd33acc0a8940fc36fe97a9a9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ef938b9a97cc35d911120950648c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a37ef938b9a97cc35d911120950648c55">asMatMul</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop)</td></tr>
<tr class="separator:a37ef938b9a97cc35d911120950648c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d03b4fd164ef6a88a2e4774d68934"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#adc5d03b4fd164ef6a88a2e4774d68934">plutoFuse</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop0, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop1, int nestLevel0=0, int nestLevel1=0, int fusableOverlapThreshold=1, bool doSimplify=true)</td></tr>
<tr class="separator:adc5d03b4fd164ef6a88a2e4774d68934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926046480d77aa1e798bed45c78a8898"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a926046480d77aa1e798bed45c78a8898">plutoPermute</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop, int nestLevel=0, bool doSimplify=true)</td></tr>
<tr class="separator:a926046480d77aa1e798bed45c78a8898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f7376da162b5975c8e00d41aeaab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#aa50f7376da162b5975c8e00d41aeaab9">autoSchedule</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target, const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="namespacefreetensor.html#a30f671564d68303583094f074bd5b6e8">RandTrace</a> &gt; &amp;trace=nullptr)</td></tr>
<tr class="separator:aa50f7376da162b5975c8e00d41aeaab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b9fb3ba9c1f7fe39e2304610e0314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a691b9fb3ba9c1f7fe39e2304610e0314">autoInline</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:a691b9fb3ba9c1f7fe39e2304610e0314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7018c4446baf1db134a11d112462370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#af7018c4446baf1db134a11d112462370">autoUseLib</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:af7018c4446baf1db134a11d112462370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d944c1a96e055d5a5491cc086ba70e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a2d944c1a96e055d5a5491cc086ba70e6">autoReorder</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:a2d944c1a96e055d5a5491cc086ba70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49494394c6a058a0e0b67d4eedc76587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a49494394c6a058a0e0b67d4eedc76587">autoSwap</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:a49494394c6a058a0e0b67d4eedc76587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dede285eb0d018cc2502589f565d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a14dede285eb0d018cc2502589f565d4b">autoPluto</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:a14dede285eb0d018cc2502589f565d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7bd97f2a8bfb6b853d959cc7b0636f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a3a7bd97f2a8bfb6b853d959cc7b0636f">autoFissionFuse</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target, const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="namespacefreetensor.html#a30f671564d68303583094f074bd5b6e8">RandTrace</a> &gt; &amp;trace=nullptr)</td></tr>
<tr class="separator:a3a7bd97f2a8bfb6b853d959cc7b0636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36968be3b8f0d74c315c3565c5572ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a36968be3b8f0d74c315c3565c5572ba2">autoParallelize</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:a36968be3b8f0d74c315c3565c5572ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a336810508f2fd8fd9bb1c761a327d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a11a336810508f2fd8fd9bb1c761a327d">autoSetMemType</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:a11a336810508f2fd8fd9bb1c761a327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ae1948ed53fbe5378905c90feb0d73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a38ae1948ed53fbe5378905c90feb0d73">autoUnroll</a> (const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;target)</td></tr>
<tr class="separator:a38ae1948ed53fbe5378905c90feb0d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de65b349dc7f8dedb0180b9857ed951"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structfreetensor_1_1AutoScheduleTuneTrial.html">AutoScheduleTuneTrial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a0de65b349dc7f8dedb0180b9857ed951">tuneAutoSchedule</a> (int nBatch, int batchSize, const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Device.html">Device</a> &gt; &amp;device, const std::vector&lt; <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Array.html">Array</a> &gt; &gt; &amp;args, const std::unordered_map&lt; std::string, <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Array.html">Array</a> &gt; &gt; &amp;kws={}, const std::regex &amp;toLearn=std::regex{&quot;.*&quot;})</td></tr>
<tr class="separator:a0de65b349dc7f8dedb0180b9857ed951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a37474d22958f1e5ce605d8ed1677fd95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a37474d22958f1e5ce605d8ed1677fd95">beginTransaction</a> ()</td></tr>
<tr class="separator:a37474d22958f1e5ce605d8ed1677fd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c17317f3ffca4cd9d2aef8fce6cd3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a14c17317f3ffca4cd9d2aef8fce6cd3f">commitTransaction</a> ()</td></tr>
<tr class="separator:a14c17317f3ffca4cd9d2aef8fce6cd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b83f0259f29692a0a587b9f71d0a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a63b83f0259f29692a0a587b9f71d0a82">abortTransaction</a> ()</td></tr>
<tr class="separator:a63b83f0259f29692a0a587b9f71d0a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad4628c70cf4624d39ceef40f517cf783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1ID.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ad4628c70cf4624d39ceef40f517cf783">fuse</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop0, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop1, bool strict=false)</td></tr>
<tr class="separator:ad4628c70cf4624d39ceef40f517cf783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8d6427f95b978b56357b01406d739c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1ID.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a2a8d6427f95b978b56357b01406d739c">fuse</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop0, bool strict=false)</td></tr>
<tr class="separator:a2a8d6427f95b978b56357b01406d739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a47648c797180e57a2c78438c4daad7b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a47648c797180e57a2c78438c4daad7b5">setMemType</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, <a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a> mtype)</td></tr>
<tr class="separator:a47648c797180e57a2c78438c4daad7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5678eb8a114d1f0993ce35835b47559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ae5678eb8a114d1f0993ce35835b47559">setMemType</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, <a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a> mtype, bool rejectIndirectAccess)</td></tr>
<tr class="separator:ae5678eb8a114d1f0993ce35835b47559"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acf8585443368254e352dbe9e6408978a" name="acf8585443368254e352dbe9e6408978a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8585443368254e352dbe9e6408978a">&#9670;&#160;</a></span>IDMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;<a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>&gt; <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">freetensor::Schedule::IDMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a84f1476fcab9676d4311a579c32a4416" name="a84f1476fcab9676d4311a579c32a4416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f1476fcab9676d4311a579c32a4416">&#9670;&#160;</a></span>Schedule() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">freetensor::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cda3d04400a0c0a162eb5769e2d20d5" name="a5cda3d04400a0c0a162eb5769e2d20d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cda3d04400a0c0a162eb5769e2d20d5">&#9670;&#160;</a></span>Schedule() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">freetensor::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>ast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2318d60c8c228271327668df47785fc7" name="a2318d60c8c228271327668df47785fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2318d60c8c228271327668df47785fc7">&#9670;&#160;</a></span>Schedule() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">freetensor::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac86c499bba4ac099f22c00233d7a17f4" name="ac86c499bba4ac099f22c00233d7a17f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86c499bba4ac099f22c00233d7a17f4">&#9670;&#160;</a></span>Schedule() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">freetensor::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a63b83f0259f29692a0a587b9f71d0a82" name="a63b83f0259f29692a0a587b9f71d0a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b83f0259f29692a0a587b9f71d0a82">&#9670;&#160;</a></span>abortTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::abortTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37ef938b9a97cc35d911120950648c55" name="a37ef938b9a97cc35d911120950648c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ef938b9a97cc35d911120950648c55">&#9670;&#160;</a></span>asMatMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::asMatMul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform nested loops to be a external call to a matrix multiplication</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td><a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop cannot be transformed to be a matrix multiplication </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a406476c26709567e73b443121335f7f7" name="a406476c26709567e73b443121335f7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406476c26709567e73b443121335f7f7">&#9670;&#160;</a></span>ast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp; freetensor::Schedule::ast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>: The statements being transformed, without a function signature </dd></dl>

</div>
</div>
<a id="a3a7bd97f2a8bfb6b853d959cc7b0636f" name="a3a7bd97f2a8bfb6b853d959cc7b0636f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7bd97f2a8bfb6b853d959cc7b0636f">&#9670;&#160;</a></span>autoFissionFuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoFissionFuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="namespacefreetensor.html#a30f671564d68303583094f074bd5b6e8">RandTrace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically fuse consecutive loops or vice versa using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
    <tr><td class="paramname">trace</td><td>: Random decision tarce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a691b9fb3ba9c1f7fe39e2304610e0314" name="a691b9fb3ba9c1f7fe39e2304610e0314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691b9fb3ba9c1f7fe39e2304610e0314">&#9670;&#160;</a></span>autoInline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoInline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically inline very-small VarDef nodes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36968be3b8f0d74c315c3565c5572ba2" name="a36968be3b8f0d74c315c3565c5572ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36968be3b8f0d74c315c3565c5572ba2">&#9670;&#160;</a></span>autoParallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoParallelize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically parallelize some loops using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14dede285eb0d018cc2502589f565d4b" name="a14dede285eb0d018cc2502589f565d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14dede285eb0d018cc2502589f565d4b">&#9670;&#160;</a></span>autoPluto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoPluto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically apply pluto-based schedules</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d944c1a96e055d5a5491cc086ba70e6" name="a2d944c1a96e055d5a5491cc086ba70e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d944c1a96e055d5a5491cc086ba70e6">&#9670;&#160;</a></span>autoReorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoReorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automaticaly reorder loops in a loop nest</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa50f7376da162b5975c8e00d41aeaab9" name="aa50f7376da162b5975c8e00d41aeaab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f7376da162b5975c8e00d41aeaab9">&#9670;&#160;</a></span>autoSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoSchedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="namespacefreetensor.html#a30f671564d68303583094f074bd5b6e8">RandTrace</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>trace</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatic scheduling using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
    <tr><td class="paramname">trace</td><td>: Random decision tarce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a336810508f2fd8fd9bb1c761a327d" name="a11a336810508f2fd8fd9bb1c761a327d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a336810508f2fd8fd9bb1c761a327d">&#9670;&#160;</a></span>autoSetMemType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoSetMemType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically set memory types using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49494394c6a058a0e0b67d4eedc76587" name="a49494394c6a058a0e0b67d4eedc76587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49494394c6a058a0e0b67d4eedc76587">&#9670;&#160;</a></span>autoSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoSwap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically swap statements to enable more fission or fusion</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38ae1948ed53fbe5378905c90feb0d73" name="a38ae1948ed53fbe5378905c90feb0d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ae1948ed53fbe5378905c90feb0d73">&#9670;&#160;</a></span>autoUnroll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoUnroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically unroll loops using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7018c4446baf1db134a11d112462370" name="af7018c4446baf1db134a11d112462370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7018c4446baf1db134a11d112462370">&#9670;&#160;</a></span>autoUseLib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoUseLib </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Target.html">Target</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(Experimental) Automatically use external libs using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37474d22958f1e5ce605d8ed1677fd95" name="a37474d22958f1e5ce605d8ed1677fd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37474d22958f1e5ce605d8ed1677fd95">&#9670;&#160;</a></span>beginTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::beginTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transaction of schedules</p>
<p>Schedules are applied in transactions. A transaction is created with <code><a class="el" href="classfreetensor_1_1Schedule.html#a37474d22958f1e5ce605d8ed1677fd95">beginTransaction()</a></code>, applied as a whole with <code><a class="el" href="classfreetensor_1_1Schedule.html#a14c17317f3ffca4cd9d2aef8fce6cd3f">commitTransaction()</a></code>, and can be aborted with <code><a class="el" href="classfreetensor_1_1Schedule.html#a63b83f0259f29692a0a587b9f71d0a82">abortTransaction()</a></code></p>
<p>Transactions can be nested. Technically, each schedule is by itself a inner-most transaction, while a <code><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a></code> object defines the outer-most transaction, but these inner-most and outer-most transcations are invisible to users </p>

</div>
</div>
<a id="adb236565d0d590d7f4ee357d7b06911d" name="adb236565d0d590d7f4ee357d7b06911d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb236565d0d590d7f4ee357d7b06911d">&#9670;&#160;</a></span>blend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::blend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unroll a loop and interleave statements from each iteration</p>
<p>E.g.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0 to 2 {</div>
<div class="line">  f(i);</div>
<div class="line">  g(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>will be transformed to be</p>
<div class="fragment"><div class="line">f(0);</div>
<div class="line">f(1);</div>
<div class="line">g(0);</div>
<div class="line">g(1);</div>
</div><!-- fragment --><p>Virtual threads in TVM can be implemented via blend</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop being transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop is not found, the loop length is not a constant, or the dependences cannot be solved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcb75fe9ab13e88589e3eeb6de82a854" name="adcb75fe9ab13e88589e3eeb6de82a854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb75fe9ab13e88589e3eeb6de82a854">&#9670;&#160;</a></span>cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a>&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cache a variable into a new local variable</p>
<p>All needed data will be filled into the cache first, then all reads and writes will be directed to the cache, and finally all needed data will be flushed from the cache</p>
<p>Note for reduction: This transformation preserves the computation order. It will transform</p>
<div class="fragment"><div class="line">a += x</div>
<div class="line">a += y</div>
</div><!-- fragment --><p>to</p>
<div class="fragment"><div class="line">a.cache = a + x + y</div>
<div class="line">a = a.cache</div>
</div><!-- fragment --><p>If you need a "real" cache for reduction, which reorders the computation, use <code>cache_reduction</code> instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement or block (e.g. an If or a For) to be modified </td></tr>
    <tr><td class="paramname">var</td><td>: name of the variable to be cached </td></tr>
    <tr><td class="paramname">mtype</td><td>: where to cache </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the <a class="el" href="classfreetensor_1_1ID.html">ID</a> or name is not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: (<a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that fills the cache, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that flushes from the cache, name of the cache variable, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef node of the cache variable) </dd></dl>

</div>
</div>
<a id="a6e3c690de5bdcec52d0dbacf9d1b2a2d" name="a6e3c690de5bdcec52d0dbacf9d1b2a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3c690de5bdcec52d0dbacf9d1b2a2d">&#9670;&#160;</a></span>cacheReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::cacheReduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a>&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform local reductions (e.g. sum) in a local variable first, and then reduce the local result to the global variable</p>
<p>E.g.</p>
<div class="fragment"><div class="line">a += x</div>
<div class="line">a += y</div>
</div><!-- fragment --><p>will be transformed to be</p>
<div class="fragment"><div class="line">a.cache = x + y</div>
<div class="line">a += a.cache</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement or block (e.g. an If or a For) to be modified </td></tr>
    <tr><td class="paramname">var</td><td>: name of the variable to be cached. Only reductions are allowed on <code>var</code> in <code>stmt</code>. Plain reads or writes are not allowed </td></tr>
    <tr><td class="paramname">mtype</td><td>: where to cache </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the <a class="el" href="classfreetensor_1_1ID.html">ID</a> or name is not found, or there are unsupported reads or writes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: (<a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that initialize the cache, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that reduces the local result to the global result, name of the cache variable, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef node of the cache variable) </dd></dl>

</div>
</div>
<a id="a14c17317f3ffca4cd9d2aef8fce6cd3f" name="a14c17317f3ffca4cd9d2aef8fce6cd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c17317f3ffca4cd9d2aef8fce6cd3f">&#9670;&#160;</a></span>commitTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::commitTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d9e820117a0bb7341541f7e338e1e73" name="a4d9e820117a0bb7341541f7e338e1e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9e820117a0bb7341541f7e338e1e73">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> freetensor::Schedule::find </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the only one nodes in the current AST satisfying a given condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>: A callback that returns true for acceptance, or a <code><a class="el" href="classfreetensor_1_1Selector.html">Selector</a></code>, or an <code><a class="el" href="classfreetensor_1_1ID.html">ID</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>: if there is more than one, or there is no node found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5574f50763b75ad856832a458b563f65" name="a5574f50763b75ad856832a458b563f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5574f50763b75ad856832a458b563f65">&#9670;&#160;</a></span>findAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt; freetensor::Schedule::findAll </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find all nodes (maybe non-existing) in the current AST satisfying a given condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>: A callback that returns true for acceptance, or a <code><a class="el" href="classfreetensor_1_1Selector.html">Selector</a></code>, or an <code><a class="el" href="classfreetensor_1_1ID.html">ID</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e8774a9abb8156dceb92789c8aec360" name="a6e8774a9abb8156dceb92789c8aec360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8774a9abb8156dceb92789c8aec360">&#9670;&#160;</a></span>findAtLeastOne()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt; freetensor::Schedule::findAtLeastOne </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find all nodes (at least one) in the current AST satisfying a given condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>: A callback that returns true for acceptance, or a <code><a class="el" href="classfreetensor_1_1Selector.html">Selector</a></code>, or an <code><a class="el" href="classfreetensor_1_1ID.html">ID</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c3a08f444cfd3d3561c216ac86d33fd" name="a4c3a08f444cfd3d3561c216ac86d33fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3a08f444cfd3d3561c216ac86d33fd">&#9670;&#160;</a></span>fission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">Schedule::IDMap</a>, <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">Schedule::IDMap</a> &gt; freetensor::Schedule::fission </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#a2b0728b023b746c7fb73d4f24a6bb15e">FissionSide</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>splitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowEnlarge</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix0</em> = <code>&quot;.0&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix1</em> = <code>&quot;.1&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fission a loop into two loops each containing part of the statements, one followed by another</p>
<p>To split loop into two nested loops, use <code>split</code> instead</p>
<p>Statements inside the original loop will be distributed to one or both (happening if they are scope statements) loops. If a statement is originally labeled "S", it can be selected by "$fission.0{S}" (from the first loop) or "$fission.1{S}" (from the second loop) after fission. If one of the resulting loop has an empty body, it will be removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop to be fissioned </td></tr>
    <tr><td class="paramname">side</td><td>: If <code>After</code>, <code>splitter</code> is the last statement of the first loop. If <code>Before</code>, <code>splitter</code> is the first statement of the second loop </td></tr>
    <tr><td class="paramname">splitter</td><td>: Where to fission the loop </td></tr>
    <tr><td class="paramname">allowEnlarge</td><td>: If true, try to avoid dependence by enlarging some <code>VarDef</code> nodes. If false, throw <code><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></code> in such cases. </td></tr>
    <tr><td class="paramname">suffix0</td><td>: The suffix in the <code>op</code> of metadata of result part 0. If empty, the fissioned part 0 preserves original <a class="el" href="classfreetensor_1_1ID.html">ID</a> and metadata. Cannot be empty together with <code>suffix1</code>. </td></tr>
    <tr><td class="paramname">suffix1</td><td>: The suffix in the <code>op</code> of metadata of result part 1. If empty, the fissioned part 1 preserves original <a class="el" href="classfreetensor_1_1ID.html">ID</a> and metadata. Cannot be empty together with <code>suffix0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if any dependence cannot be resolved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: ({old <a class="el" href="classfreetensor_1_1ID.html">ID</a> -&gt; new <a class="el" href="classfreetensor_1_1ID.html">ID</a> in 1st loop}, {old <a class="el" href="classfreetensor_1_1ID.html">ID</a> -&gt; new <a class="el" href="classfreetensor_1_1ID.html">ID</a> in 2nd loop}). If a loop is removed because it has an empty body, it will not be in the returned map </dd></dl>

</div>
</div>
<a id="ad29861fd233c49e64fa0df3ef76b9ff0" name="ad29861fd233c49e64fa0df3ef76b9ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29861fd233c49e64fa0df3ef76b9ff0">&#9670;&#160;</a></span>fork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> freetensor::Schedule::fork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the <code><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a></code> object for trying different scheduling decisions in the future</p>
<p>The <code>fork</code>ed object shares the same <code>MemoizedSchedule</code> with the original one, so common decisions can be saved and reused</p>
<p>The <code>fork</code>ed object shares the same <code><a class="el" href="classfreetensor_1_1RandCtx.html">RandCtx</a></code> objects, so it can learn from multiple scheduling trials </p>

</div>
</div>
<a id="ad23d1f71efbc801f2cfa34ad8535ebaa" name="ad23d1f71efbc801f2cfa34ad8535ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23d1f71efbc801f2cfa34ad8535ebaa">&#9670;&#160;</a></span>func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a> freetensor::Schedule::func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>: The function being transformed </dd></dl>

</div>
</div>
<a id="a2a8d6427f95b978b56357b01406d739c" name="a2a8d6427f95b978b56357b01406d739c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8d6427f95b978b56357b01406d739c">&#9670;&#160;</a></span>fuse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1ID.html">ID</a> freetensor::Schedule::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4628c70cf4624d39ceef40f517cf783" name="ad4628c70cf4624d39ceef40f517cf783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4628c70cf4624d39ceef40f517cf783">&#9670;&#160;</a></span>fuse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1ID.html">ID</a> freetensor::Schedule::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fuse two directly following loops with the same length into one</p>
<p>To merge nested loops into one, use <code>merge</code> instead</p>
<p><code>parallelize</code>, <code>unroll</code> and <code>vectorize</code> properties will be reset on the fused loop</p>
<p>Suppose the original loops are labeled "L1" and "L2", the fused loop can be selected by "$fuse{L1, L2}"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop0</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the leading loop </td></tr>
    <tr><td class="paramname">loop1</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the following loop. If omitted, it will try to find a following loop of <code>loop0</code> </td></tr>
    <tr><td class="paramname">strict</td><td>: If true, throw an error if unable to determine whether the two loops are of the same length </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the two loops are not directly following, the two loops are not of the same length, or there is any dependence cannot be resolved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the result loop </dd></dl>

</div>
</div>
<a id="a9bfc2f98d42e75a3838eaa0166b802e2" name="a9bfc2f98d42e75a3838eaa0166b802e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfc2f98d42e75a3838eaa0166b802e2">&#9670;&#160;</a></span>inlining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::inlining </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a variable. When the variable is used, recompute its value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable. It can not be an I/O varible </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable cannot be completely removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae89d66befe98d65de717c0400e32fbc6" name="ae89d66befe98d65de717c0400e32fbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d66befe98d65de717c0400e32fbc6">&#9670;&#160;</a></span>logs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacefreetensor.html#a3ade010f117f2ddf99e1c076eae94715">ScheduleLog</a> &amp; freetensor::Schedule::logs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>: Logs of all schedules applied </dd></dl>

</div>
</div>
<a id="aa1a2b69d757e3277d357d76fc06c5c82" name="aa1a2b69d757e3277d357d76fc06c5c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a2b69d757e3277d357d76fc06c5c82">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1ID.html">ID</a> freetensor::Schedule::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge two directly nested loops into one</p>
<p>To fuse consecutive loops, use <code>fuse</code> instead</p>
<p><code>parallelize</code>, <code>unroll</code> and <code>vectorize</code> properties will be reset on the merged loop</p>
<p>Suppose the original loops are labeled "L1" and "L2", the merged loop can be selected by "$merge{L1, L2}"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop1,loop2</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loops to be merged, can be in any order </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loops are not directly nested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the merged loop </dd></dl>

</div>
</div>
<a id="a6e8f42786f010644795cac660b690b61" name="a6e8f42786f010644795cac660b690b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8f42786f010644795cac660b690b61">&#9670;&#160;</a></span>moveTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::moveTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#ac490983b87e6acdba7919a1cf57245c3">MoveToSide</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move a statement to a new position</p>
<p>This is a composite schedule command, which is implemented with other commands</p>
<p>If moving a statement out of some loops, identical loops will be added around the moved statement, which is equivalent to fission these loops</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement to be moved </td></tr>
    <tr><td class="paramname">side</td><td>: Whether <code>stmt</code> will be BEFORE or AFTER <code>dst @param dst : Insert</code>stmt` to be directly after this statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if there is no feasible path to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: (The new <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the moved statement, The out-most newly introduced statments including the added loops) </dd></dl>

</div>
</div>
<a id="ad805cbf90171357669445e969d69ebd8" name="ad805cbf90171357669445e969d69ebd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad805cbf90171357669445e969d69ebd8">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> &amp; freetensor::Schedule::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afed97de683ffe2a24b50c167cfc1f273" name="afed97de683ffe2a24b50c167cfc1f273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed97de683ffe2a24b50c167cfc1f273">&#9670;&#160;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::parallelize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacefreetensor.html#a6d19bf2262d0cd0af3903283c9722088">ParallelScope</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowReduction</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark a loop with a parallel implementation</p>
<p>This schedule follows a fork-join model: multiple workers (abstract threads) are created (but physically the threads may be cached in a thread pool) when the loop begins, do their jobs in parallel, and join when the loop ends</p>
<p>OpenMP threads follow a typical fork-join model. CUDA threads run in a bulk-synchronous parallel (BSP) model, which can also be mimiked by the fork-join model: All threads start when the kernel get launched, but they only begin to do their jobs when the parallel loop begins. Nevertheless, the fork-join model needs the following extension to fully mimic a BSP model:</p>
<p>Taking CUDA as an example, we allow binding a loop to <code>threadIdx.x</code> inside another loop bound to <code>threadIdx.x</code>, which is illegal in a classic fork-join model. For example, we may implement a matmul with collaborative fetch as below:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i : threadIdx.x  # Li</div>
<div class="line">  <span class="keywordflow">for</span> j : threadIdx.y  # Lj</div>
<div class="line">    local_sum = 0  # In gpu/local memory, unique to (i, j)</div>
<div class="line">    <span class="keywordflow">for</span> k0  # Lk0</div>
<div class="line">      <span class="keywordflow">for</span> k : threadIdx.y  # Lk1_a</div>
<div class="line">        A_cache[k] = A[i, k]  # In gpu/shared, shared by different j</div>
<div class="line">      <span class="keywordflow">for</span> k : threadIdx.x  # Lk1_b</div>
<div class="line">        B_cache[k] = B[k, j]  # In gpu/shared, shared by different i</div>
<div class="line">      <span class="keywordflow">for</span> k  # Lk1_c</div>
<div class="line">        <a class="code hl_function" href="namespacefreetensor.html#a0c9ed402d06313ae47881e5da1a4987c">sum</a> += A_cache[k] * B_cache[k]</div>
<div class="line">    C[i, j] = local_sum</div>
<div class="ttc" id="anamespacefreetensor_html_a0c9ed402d06313ae47881e5da1a4987c"><div class="ttname"><a href="namespacefreetensor.html#a0c9ed402d06313ae47881e5da1a4987c">freetensor::sum</a></div><div class="ttdeci">PBMap sum(T &amp;&amp;lhs, U &amp;&amp;rhs)</div><div class="ttdef"><b>Definition:</b> presburger.h:555</div></div>
</div><!-- fragment --><p>A seemingly plausible solution to avoid this extension is to reorder <code>Lk0</code> to outer-most, and then move <code>Lk1_a</code> and <code>Lk1_b</code> out of <code>Li</code> or <code>Lj</code>. This resolves the nested <code>threadIdx.x</code> and <code>threadIdx.y</code> binding problem by running <code>Li+Lk1_a</code>, <code>Lj+Lk1_b</code> and <code>Li+Lj</code> interleavingly, instead of running <code>Lk1_a</code> and <code>Lk1_b</code> inside <code>Li+Lj</code>. However, this approach is illegal, because the local variable <code>local_sum</code> can no longer be kept inside the body of <code>Li</code> and <code>Lj</code>: It has to be reused across multiple runs of <code>Li</code> and <code>Lj</code></p>
<p>Please also note that we can bind one <code>threadIdx.x</code> to two loops only when the body statement is loop-invariant to one of them. For example, the following binding is still illegal, even in our extended fork-join model, because it violates its serial semantics:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i : threadIdx.x</div>
<div class="line">  <span class="keywordflow">for</span> j : threadIdx.x</div>
<div class="line">    A[i, j] ++</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
    <tr><td class="paramname">parallel</td><td>: Parallel scope </td></tr>
    <tr><td class="paramname">allowReduction</td><td>: If false, throw <a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a> if this schedule would introduce a parallel reduction </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop is not found or unable to be parallelized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a575b7a57ec6518dc5c6cd53bc8d2b8cc" name="a575b7a57ec6518dc5c6cd53bc8d2b8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575b7a57ec6518dc5c6cd53bc8d2b8cc">&#9670;&#160;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::permute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loopsId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::vector&lt; <a class="el" href="namespacefreetensor.html#acfa6f07a5497b3d187fe112708aa335b">Expr</a> &gt;(std::vector&lt; <a class="el" href="namespacefreetensor.html#acfa6f07a5497b3d187fe112708aa335b">Expr</a> &gt;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>transformFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfreetensor_1_1Permute.html">Permute</a> perfectly nested loops (directly nested loops without statements in between) with the given loop space transformation function</p>
<p>The transformed loops follow ascending lexical order of the transformed terms returned by <code>transformFunc</code> when called with original iteration variables</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopsId</td><td>: the list of IDs of perfectly nested loops to be permuted </td></tr>
    <tr><td class="paramname">transformFunc</td><td>: the loop space transformation function, should be bijective </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loops are not perfectly nested, or the permutation is not bijective, or the permutation breaks certain dependence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: the list of IDs of permuted loops </dd></dl>
<p>FIXME: put this into schedule logs</p>

</div>
</div>
<a id="adc5d03b4fd164ef6a88a2e4774d68934" name="adc5d03b4fd164ef6a88a2e4774d68934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5d03b4fd164ef6a88a2e4774d68934">&#9670;&#160;</a></span>plutoFuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt; freetensor::Schedule::plutoFuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nestLevel0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nestLevel1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fusableOverlapThreshold</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doSimplify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use Pluto+ algorithm to permute and fuse two loops, with as most parallelizable loops as possible at outermost levels. The two loops are required to be consequent; all directly nested levels are detected and subject to permutation. Remaining levels that cannot be fused are left inside the fused loops as two statements</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop0</td><td>: The first loop to fuse </td></tr>
    <tr><td class="paramname">loop1</td><td>: The second loop to fuse </td></tr>
    <tr><td class="paramname">nestLevel0</td><td>: The number of nesting levels of loop 0 to be considered, defaults to maximum possible </td></tr>
    <tr><td class="paramname">nestLevel1</td><td>: The number of nesting levels of loop 1 to be considered, defaults to maximum possible </td></tr>
    <tr><td class="paramname">fusableOverlapThreshold</td><td>: The minimum overlapping size of two loops to be regarded fusable. Defaults to 1 </td></tr>
    <tr><td class="paramname">doSimplify</td><td>: Whether the result is simplified by the way, defaults to true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;ID, int&gt; : The <a class="el" href="classfreetensor_1_1ID.html">ID</a> of fused loop and level of parallelizable loops </dd></dl>

</div>
</div>
<a id="a926046480d77aa1e798bed45c78a8898" name="a926046480d77aa1e798bed45c78a8898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926046480d77aa1e798bed45c78a8898">&#9670;&#160;</a></span>plutoPermute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt; freetensor::Schedule::plutoPermute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nestLevel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doSimplify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use Pluto+ algorithm to permute a single loop, with as most parallelizable loops as possible at outermost levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: The loop to permute </td></tr>
    <tr><td class="paramname">nestLevel0</td><td>: The number of nesting levels to be considered, defaults to maximum possible </td></tr>
    <tr><td class="paramname">doSimplify</td><td>: Whether the result is simplified by the way, defaults to true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::pair&lt;ID, int&gt; : The <a class="el" href="classfreetensor_1_1ID.html">ID</a> of permuted loop and level of parallelizable loops </dd></dl>

</div>
</div>
<a id="a7152785074bdd363a5eb0091819b9152" name="a7152785074bdd363a5eb0091819b9152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7152785074bdd363a5eb0091819b9152">&#9670;&#160;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfreetensor_1_1Reorder.html">Reorder</a> directly nested loops</p>
<p>To swap consecutive loops, use <code>swap</code> instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>: Vector of loop IDs. The requested order of the loops </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the input is invalid or there are breaking dependences </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5acb3fd33acc0a8940fc36fe97a9a9da" name="a5acb3fd33acc0a8940fc36fe97a9a9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb3fd33acc0a8940fc36fe97a9a9da">&#9670;&#160;</a></span>separateTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::separateTail </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noDuplicateVarDefs</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seperate main iterations and tail iterations of a loop</p>
<p>E.g.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0 -&gt; 3 {</div>
<div class="line">  <span class="keywordflow">for</span> j = 0 -&gt; 4 {</div>
<div class="line">     <span class="keywordflow">if</span> (i * 4 + j &lt; 10) {</div>
<div class="line">       ...</div>
<div class="line">     }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Each loop will be separated into 2 parts: the body and the tail. After simplification, the program will finally be transformed to</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0 -&gt; 2 {</div>
<div class="line">  <span class="keywordflow">for</span> j = 0 -&gt; 4 {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> j = 0 -&gt; 2 {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Ideally, all programs can benefit from this schedule. However, this schedule may greatly increase the program size and make the compiling time way too long. Therefore, this transformation is implemented as a schedule, which can be applied optionally. (TODO: Optionally apply this schedule to part of the program)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noDuplicateVarDefs</td><td>: If there is two VarDef nodes in two branches, it may result in doubled memory use, since different thread may go to different branch. Set this parameter to true to stop duplicating VarDef nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47648c797180e57a2c78438c4daad7b5" name="a47648c797180e57a2c78438c4daad7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47648c797180e57a2c78438c4daad7b5">&#9670;&#160;</a></span>setMemType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::setMemType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a>&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change where a variable is stored</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">mtype</td><td>: Where the variable should be stored </td></tr>
    <tr><td class="paramname">rejectIndirectAccess</td><td>: Registers usually do not support indirect access. If a variable is accessed indirectly, setting it to use registers is meaningless even successful. If this parameter is set to true, throw an exception if the variable being set is accessed indirectly. Specifically, two types of access are considered indirect: 1) The index is a load from another variable, or 2) The index is a loop iterator and the loop has a dynamic length (which can not be unrolled by a backend compiler). By default, this parameter is determined automatically by <code>mtype</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable is not found, or if rejecting an indirect access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5678eb8a114d1f0993ce35835b47559" name="ae5678eb8a114d1f0993ce35835b47559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5678eb8a114d1f0993ce35835b47559">&#9670;&#160;</a></span>setMemType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::setMemType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a>&#160;</td>
          <td class="paramname"><em>mtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rejectIndirectAccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92a8d59c65897666a3380aa5bb887736" name="a92a8d59c65897666a3380aa5bb887736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a8d59c65897666a3380aa5bb887736">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nparts</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a loop into two nested loops</p>
<p>To fission a loop into two consecutive loops, use <code>fission</code> instead</p>
<p>Two modes are provided:</p>
<ol type="1">
<li>Specify <code>factor</code> and leave <code>nparts</code> to -1. It will result in an outer loop with length <code>ceil(n / factor)</code>, and an inner loop with length <code>factor</code>, where <code>n</code> is the original loop length added by <code>shift</code>. The original iterator <code>i</code> will be transformed to <code>i0 * factor + i1</code>, where <code>i0</code> and <code>i1</code> are the iterators of the new outer and inner loops, respectively</li>
<li>Specify <code>nparts</code> and leave <code>factor</code> to -1. It will result in an outer loop with length <code>nparts</code>, and an inner loop with length <code>ceil(n / nparts)</code>, where <code>n</code> is the original loop length added by <code>shift</code>. The original iterator <code>i</code> will be transformed to <code>i0 * ceil(n / nparts) + i1</code>, where <code>i0</code> and <code>i1</code> are the iterators of the new outer and inner loops, respectively</li>
</ol>
<p>Please note that the second mode will introduce an <code>i0 * ceil(n / nparts)</code> factor into the program, which cannot be recognized by polyhedral analysis, which may hinder some following schedules. If possible, please use the first mode, and then reorder the inner and outer loops</p>
<p>Suppose the original loop is labeled "L", the split two loops can be selected by "$split.0{L}" (the outer loop) and "$split.1{L}" (the inner loop). If one of the resulting loop is proved to have only a single iteration, it will be removed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop to be split </td></tr>
    <tr><td class="paramname">factor</td><td>: Length of the inner loop. Set to -1 if using <code>nparts</code> </td></tr>
    <tr><td class="paramname">nparts</td><td>: Length of the outer loop. Set to -1 if using <code>factor</code> </td></tr>
    <tr><td class="paramname">shift</td><td>: Shift of iteration base. Defaults to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop is not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: (outer loop <a class="el" href="classfreetensor_1_1ID.html">ID</a>, inner loop <a class="el" href="classfreetensor_1_1ID.html">ID</a>), either <a class="el" href="classfreetensor_1_1ID.html">ID</a> can be invalid if the loop is proved to have only a single iteration </dd></dl>

</div>
</div>
<a id="ade01fd2d0d808e2e6f76ee11af33c33d" name="ade01fd2d0d808e2e6f76ee11af33c33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade01fd2d0d808e2e6f76ee11af33c33d">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfreetensor_1_1Swap.html">Swap</a> statements in the same block</p>
<p>To reorder nested loops, use <code>reorder</code> instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>: list of IDs of the statements </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the statements are not found or the dependences cannot be solved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0de65b349dc7f8dedb0180b9857ed951" name="a0de65b349dc7f8dedb0180b9857ed951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de65b349dc7f8dedb0180b9857ed951">&#9670;&#160;</a></span>tuneAutoSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structfreetensor_1_1AutoScheduleTuneTrial.html">AutoScheduleTuneTrial</a> &gt; freetensor::Schedule::tuneAutoSchedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>batchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Device.html">Device</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Array.html">Array</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; std::string, <a class="el" href="classfreetensor_1_1Ref.html">Ref</a>&lt; <a class="el" href="classfreetensor_1_1Array.html">Array</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>kws</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::regex &amp;&#160;</td>
          <td class="paramname"><em>toLearn</em> = <code>std::regex{&quot;.*&quot;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae9bde8c67ec254ea7ea1542ef74660" name="a3ae9bde8c67ec254ea7ea1542ef74660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae9bde8c67ec254ea7ea1542ef74660">&#9670;&#160;</a></span>unroll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>immediate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unroll a loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
    <tr><td class="paramname">immediate</td><td>: If false (by default), postpone the unroll procedure to the backend compiler, which saves scheduling time. If true, unroll the loop immediately, which may help further simplifications based on the unrolled result. If your purpose is just to fill the instruction cache, set it to false. If you are unrolling a loop that computes array indices, set it to true </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop is not found or length of the loop is not a constant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4afd2c54b5c306cea3ef02276278a638" name="a4afd2c54b5c306cea3ef02276278a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afd2c54b5c306cea3ef02276278a638">&#9670;&#160;</a></span>varMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::varMerge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge two dimensions of a variable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">dim</td><td>: Merge the <code>dim</code>-th and the <code>(dim + 1)</code>-th dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0527473deeef7e00524a5aa1887c974b" name="a0527473deeef7e00524a5aa1887c974b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0527473deeef7e00524a5aa1887c974b">&#9670;&#160;</a></span>varReorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::varReorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfreetensor_1_1Reorder.html">Reorder</a> the dimensions of a variable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">order</td><td>: new order of the dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable or the order is illegal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83689544088377af6145346f8046b9ee" name="a83689544088377af6145346f8046b9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83689544088377af6145346f8046b9ee">&#9670;&#160;</a></span>varSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::varSplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#aa84a1eedb0880915c25c6ba5a2aa4db5">VarSplitMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nparts</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a dimension of a variable into two</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">dim</td><td>: which dimension to be split </td></tr>
    <tr><td class="paramname">mode</td><td>: When the dimension to split is not divisible by <code>factor</code> or <code>nparts</code>, the resulting shape may become larger. In <code>FixedSize</code> mode, the actual buffer size will not be changed, and gurads will be added to prevent out-of-bound accesses. In <code>RelaxedSize</code> mode, the buffer size may increase. The <code>RelaxedSize</code> mode cannot be applied to I/O variables </td></tr>
    <tr><td class="paramname">factor</td><td>: Length of the inner (higher no.) dimension. Set to -1 if using <code>nparts</code> </td></tr>
    <tr><td class="paramname">nparts</td><td>: Length of the outer (lower no.) loop. Set to -1 if using <code>factor</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable or the dimension is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1d9ada77583888471a8378d400daf49" name="ac1d9ada77583888471a8378d400daf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d9ada77583888471a8378d400daf49">&#9670;&#160;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classfreetensor_1_1Vectorize.html">Vectorize</a> a loop</p>
<p>Please note that, as vectorization is different from architecture to achitecture, the scheduler may or may not postpone it to the backend compiler. The vectorization is a best-effort schedule</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the <a class="el" href="classfreetensor_1_1ID.html">ID</a> or name is not found, or the dependence requirement is not met </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eb270dbcfd94ec971f672850d184c59" name="a0eb270dbcfd94ec971f672850d184c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb270dbcfd94ec971f672850d184c59">&#9670;&#160;</a></span>verbose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int freetensor::Schedule::verbose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Verbose level </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="schedule_8h_source.html">schedule.h</a></li>
<li>src/<a class="el" href="schedule_8cc.html">schedule.cc</a></li>
<li>src/schedule/<a class="el" href="as__matmul_8cc.html">as_matmul.cc</a></li>
<li>src/schedule/<a class="el" href="auto__fission__fuse_8cc.html">auto_fission_fuse.cc</a></li>
<li>src/schedule/<a class="el" href="auto__inline_8cc.html">auto_inline.cc</a></li>
<li>src/schedule/<a class="el" href="auto__parallelize_8cc.html">auto_parallelize.cc</a></li>
<li>src/schedule/<a class="el" href="auto__pluto_8cc.html">auto_pluto.cc</a></li>
<li>src/schedule/<a class="el" href="auto__reorder_8cc.html">auto_reorder.cc</a></li>
<li>src/schedule/<a class="el" href="auto__set__mem__type_8cc.html">auto_set_mem_type.cc</a></li>
<li>src/schedule/<a class="el" href="auto__swap_8cc.html">auto_swap.cc</a></li>
<li>src/schedule/<a class="el" href="auto__unroll_8cc.html">auto_unroll.cc</a></li>
<li>src/schedule/<a class="el" href="auto__use__lib_8cc.html">auto_use_lib.cc</a></li>
<li>src/schedule/<a class="el" href="blend_8cc.html">blend.cc</a></li>
<li>src/schedule/<a class="el" href="cache_8cc.html">cache.cc</a></li>
<li>src/schedule/<a class="el" href="fission_8cc.html">fission.cc</a></li>
<li>src/schedule/<a class="el" href="fuse_8cc.html">fuse.cc</a></li>
<li>src/schedule/<a class="el" href="inlining_8cc.html">inlining.cc</a></li>
<li>src/schedule/<a class="el" href="merge_8cc.html">merge.cc</a></li>
<li>src/schedule/<a class="el" href="move__to_8cc.html">move_to.cc</a></li>
<li>src/schedule/<a class="el" href="parallelize_8cc.html">parallelize.cc</a></li>
<li>src/schedule/<a class="el" href="permute_8cc.html">permute.cc</a></li>
<li>src/schedule/<a class="el" href="pluto_8cc.html">pluto.cc</a></li>
<li>src/schedule/<a class="el" href="reorder_8cc.html">reorder.cc</a></li>
<li>src/schedule/<a class="el" href="separate__tail_8cc.html">separate_tail.cc</a></li>
<li>src/schedule/<a class="el" href="set__mem__type_8cc.html">set_mem_type.cc</a></li>
<li>src/schedule/<a class="el" href="split_8cc.html">split.cc</a></li>
<li>src/schedule/<a class="el" href="swap_8cc.html">swap.cc</a></li>
<li>src/schedule/<a class="el" href="unroll_8cc.html">unroll.cc</a></li>
<li>src/schedule/<a class="el" href="var__merge_8cc.html">var_merge.cc</a></li>
<li>src/schedule/<a class="el" href="var__reorder_8cc.html">var_reorder.cc</a></li>
<li>src/schedule/<a class="el" href="var__split_8cc.html">var_split.cc</a></li>
<li>src/schedule/<a class="el" href="vectorize_8cc.html">vectorize.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
