<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeTensor: freetensor::Schedule Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeTensor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefreetensor.html">freetensor</a></li><li class="navelem"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfreetensor_1_1Schedule-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">freetensor::Schedule Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="schedule_8h_source.html">schedule.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acf8585443368254e352dbe9e6408978a"><td class="memItemLeft" align="right" valign="top">typedef std::unordered_map&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">IDMap</a></td></tr>
<tr class="separator:acf8585443368254e352dbe9e6408978a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a84f1476fcab9676d4311a579c32a4416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a84f1476fcab9676d4311a579c32a4416">Schedule</a> ()=default</td></tr>
<tr class="separator:a84f1476fcab9676d4311a579c32a4416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cda3d04400a0c0a162eb5769e2d20d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a5cda3d04400a0c0a162eb5769e2d20d5">Schedule</a> (const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;<a class="el" href="classfreetensor_1_1Schedule.html#ac235b9b664543453d977094741cd31a7">ast</a>, int verbose=0)</td></tr>
<tr class="separator:a5cda3d04400a0c0a162eb5769e2d20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2318d60c8c228271327668df47785fc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a2318d60c8c228271327668df47785fc7">Schedule</a> (const <a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a> &amp;<a class="el" href="classfreetensor_1_1Schedule.html#ad23d1f71efbc801f2cfa34ad8535ebaa">func</a>, int verbose=0)</td></tr>
<tr class="separator:a2318d60c8c228271327668df47785fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada66a3399fdab1b6395fce9505556327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ada66a3399fdab1b6395fce9505556327">clone</a> () const</td></tr>
<tr class="separator:ada66a3399fdab1b6395fce9505556327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23d1f71efbc801f2cfa34ad8535ebaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ad23d1f71efbc801f2cfa34ad8535ebaa">func</a> () const</td></tr>
<tr class="separator:ad23d1f71efbc801f2cfa34ad8535ebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac235b9b664543453d977094741cd31a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ac235b9b664543453d977094741cd31a7">ast</a> () const</td></tr>
<tr class="separator:ac235b9b664543453d977094741cd31a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97ecfc9af49e07cfdc90f7d8fff9919"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#af97ecfc9af49e07cfdc90f7d8fff9919">logs</a> () const</td></tr>
<tr class="separator:af97ecfc9af49e07cfdc90f7d8fff9919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f4e76f35b4baa793d72397fd0d919d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#aa8f4e76f35b4baa793d72397fd0d919d">findAll</a> (const std::function&lt; bool(const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;)&gt; &amp;<a class="el" href="namespacefreetensor.html#a5997edb53e600a6645243d5d2684f129">filter</a>) const</td></tr>
<tr class="separator:aa8f4e76f35b4baa793d72397fd0d919d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daefd3692c06c2edac13d965e8c77a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a1daefd3692c06c2edac13d965e8c77a5">find</a> (const std::function&lt; bool(const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;)&gt; &amp;<a class="el" href="namespacefreetensor.html#a5997edb53e600a6645243d5d2684f129">filter</a>) const</td></tr>
<tr class="separator:a1daefd3692c06c2edac13d965e8c77a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a54397cf8641d194b9f5a23528d942"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a76a54397cf8641d194b9f5a23528d942">findAll</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;id) const</td></tr>
<tr class="separator:a76a54397cf8641d194b9f5a23528d942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74fa57a5be44bf722618fac5a60ce41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ac74fa57a5be44bf722618fac5a60ce41">find</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;id) const</td></tr>
<tr class="separator:ac74fa57a5be44bf722618fac5a60ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8d59c65897666a3380aa5bb887736"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a92a8d59c65897666a3380aa5bb887736">split</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;id, int factor=-1, int nparts=-1, int shift=0)</td></tr>
<tr class="separator:a92a8d59c65897666a3380aa5bb887736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7152785074bdd363a5eb0091819b9152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a7152785074bdd363a5eb0091819b9152">reorder</a> (const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;order)</td></tr>
<tr class="separator:a7152785074bdd363a5eb0091819b9152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a2b69d757e3277d357d76fc06c5c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1ID.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#aa1a2b69d757e3277d357d76fc06c5c82">merge</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop1, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop2)</td></tr>
<tr class="separator:aa1a2b69d757e3277d357d76fc06c5c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54719c22533351b6b3ec37c73fb13652"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">IDMap</a>, <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">IDMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a54719c22533351b6b3ec37c73fb13652">fission</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop, <a class="el" href="namespacefreetensor.html#a2b0728b023b746c7fb73d4f24a6bb15e">FissionSide</a> side, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;splitter, const std::string &amp;suffix0=&quot;.a&quot;, const std::string &amp;suffix1=&quot;.b&quot;)</td></tr>
<tr class="separator:a54719c22533351b6b3ec37c73fb13652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade01fd2d0d808e2e6f76ee11af33c33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ade01fd2d0d808e2e6f76ee11af33c33d">swap</a> (const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;order)</td></tr>
<tr class="separator:ade01fd2d0d808e2e6f76ee11af33c33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb236565d0d590d7f4ee357d7b06911d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#adb236565d0d590d7f4ee357d7b06911d">blend</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop)</td></tr>
<tr class="separator:adb236565d0d590d7f4ee357d7b06911d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb75fe9ab13e88589e3eeb6de82a854"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#adcb75fe9ab13e88589e3eeb6de82a854">cache</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;stmt, const std::string &amp;var, <a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a> mtype)</td></tr>
<tr class="separator:adcb75fe9ab13e88589e3eeb6de82a854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c690de5bdcec52d0dbacf9d1b2a2d"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a6e3c690de5bdcec52d0dbacf9d1b2a2d">cacheReduction</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;stmt, const std::string &amp;var, <a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a> mtype)</td></tr>
<tr class="separator:a6e3c690de5bdcec52d0dbacf9d1b2a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47648c797180e57a2c78438c4daad7b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a47648c797180e57a2c78438c4daad7b5">setMemType</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, <a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a> mtype)</td></tr>
<tr class="separator:a47648c797180e57a2c78438c4daad7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83689544088377af6145346f8046b9ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a83689544088377af6145346f8046b9ee">varSplit</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, int dim, <a class="el" href="namespacefreetensor.html#aa84a1eedb0880915c25c6ba5a2aa4db5">VarSplitMode</a> mode, int factor=-1, int nparts=-1)</td></tr>
<tr class="separator:a83689544088377af6145346f8046b9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afd2c54b5c306cea3ef02276278a638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a4afd2c54b5c306cea3ef02276278a638">varMerge</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, int dim)</td></tr>
<tr class="separator:a4afd2c54b5c306cea3ef02276278a638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0527473deeef7e00524a5aa1887c974b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a0527473deeef7e00524a5aa1887c974b">varReorder</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def, const std::vector&lt; int &gt; &amp;order)</td></tr>
<tr class="separator:a0527473deeef7e00524a5aa1887c974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28085136b3ac2b360e10aa30b51a9fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1ID.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a28085136b3ac2b360e10aa30b51a9fdb">moveTo</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;stmt, <a class="el" href="namespacefreetensor.html#ac490983b87e6acdba7919a1cf57245c3">MoveToSide</a> side, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;dst)</td></tr>
<tr class="separator:a28085136b3ac2b360e10aa30b51a9fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc2f98d42e75a3838eaa0166b802e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a9bfc2f98d42e75a3838eaa0166b802e2">inlining</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;def)</td></tr>
<tr class="separator:a9bfc2f98d42e75a3838eaa0166b802e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd6430725b39cc15a3aa5cad99fa2b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a9dd6430725b39cc15a3aa5cad99fa2b1">parallelize</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop, const <a class="el" href="namespacefreetensor.html#a6d19bf2262d0cd0af3903283c9722088">ParallelScope</a> &amp;parallel)</td></tr>
<tr class="separator:a9dd6430725b39cc15a3aa5cad99fa2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae9bde8c67ec254ea7ea1542ef74660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a3ae9bde8c67ec254ea7ea1542ef74660">unroll</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop, bool immediate=false)</td></tr>
<tr class="separator:a3ae9bde8c67ec254ea7ea1542ef74660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d9ada77583888471a8378d400daf49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ac1d9ada77583888471a8378d400daf49">vectorize</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop)</td></tr>
<tr class="separator:ac1d9ada77583888471a8378d400daf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb3fd33acc0a8940fc36fe97a9a9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a5acb3fd33acc0a8940fc36fe97a9a9da">separateTail</a> (bool noDuplicateVarDefs=false)</td></tr>
<tr class="separator:a5acb3fd33acc0a8940fc36fe97a9a9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ef938b9a97cc35d911120950648c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a37ef938b9a97cc35d911120950648c55">asMatMul</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop)</td></tr>
<tr class="separator:a37ef938b9a97cc35d911120950648c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c73e1f8cd59b196aa495c56fb141d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a9c73e1f8cd59b196aa495c56fb141d8f">autoSchedule</a> (const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a9c73e1f8cd59b196aa495c56fb141d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6e8a418824aeaf48e5966d9046e8b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a7f6e8a418824aeaf48e5966d9046e8b4">autoUseLib</a> (const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a7f6e8a418824aeaf48e5966d9046e8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c1cee0944a78f2662996607cf4ffe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#af6c1cee0944a78f2662996607cf4ffe0">autoFuse</a> (const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:af6c1cee0944a78f2662996607cf4ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab49e422d97c96d24081406de659e121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#aab49e422d97c96d24081406de659e121">autoParallelize</a> (const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:aab49e422d97c96d24081406de659e121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4eeb733444a7566604e4f19f657b07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#aeb4eeb733444a7566604e4f19f657b07">autoSetMemType</a> (const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:aeb4eeb733444a7566604e4f19f657b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5c6509535b6636e718d7e3fdbc267f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a7f5c6509535b6636e718d7e3fdbc267f">autoUnroll</a> (const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;target)</td></tr>
<tr class="separator:a7f5c6509535b6636e718d7e3fdbc267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dd211db7d4944ec50c6ed69fc5ccf9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a09dd211db7d4944ec50c6ed69fc5ccf9">multiLevelTiling</a> (const <a class="el" href="structfreetensor_1_1ForsWithDataReuse.html">ForsWithDataReuse</a> &amp;target, const <a class="el" href="structfreetensor_1_1MultiLevelTilingAnnotation.html">MultiLevelTilingAnnotation</a> &amp;annotation, const std::string &amp;pat, int level)</td></tr>
<tr class="separator:a09dd211db7d4944ec50c6ed69fc5ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1371b08ed69a961b5584db8adcbfde11"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a1371b08ed69a961b5584db8adcbfde11">multiLevelTilingWithFusion</a> (const <a class="el" href="structfreetensor_1_1ForsWithDataReuse.html">ForsWithDataReuse</a> &amp;target, const <a class="el" href="structfreetensor_1_1MultiLevelTilingAnnotation.html">MultiLevelTilingAnnotation</a> &amp;annotation, const std::string &amp;pat, const <a class="el" href="structfreetensor_1_1ElementWiseInfo.html">ElementWiseInfo</a> &amp;toFuse, int level, <a class="el" href="namespacefreetensor.html#a000c2c313211c04f40116e7f8117d66b">TargetType</a> targetType, bool doCacheRead)</td></tr>
<tr class="separator:a1371b08ed69a961b5584db8adcbfde11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad4628c70cf4624d39ceef40f517cf783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1ID.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#ad4628c70cf4624d39ceef40f517cf783">fuse</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop0, const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop1, bool strict=false)</td></tr>
<tr class="separator:ad4628c70cf4624d39ceef40f517cf783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8d6427f95b978b56357b01406d739c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfreetensor_1_1ID.html">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfreetensor_1_1Schedule.html#a2a8d6427f95b978b56357b01406d739c">fuse</a> (const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;loop0, bool strict=false)</td></tr>
<tr class="separator:a2a8d6427f95b978b56357b01406d739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acf8585443368254e352dbe9e6408978a" name="acf8585443368254e352dbe9e6408978a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8585443368254e352dbe9e6408978a">&#9670;&nbsp;</a></span>IDMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unordered_map&lt;<a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>&gt; <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">freetensor::Schedule::IDMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a84f1476fcab9676d4311a579c32a4416" name="a84f1476fcab9676d4311a579c32a4416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f1476fcab9676d4311a579c32a4416">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">freetensor::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cda3d04400a0c0a162eb5769e2d20d5" name="a5cda3d04400a0c0a162eb5769e2d20d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cda3d04400a0c0a162eb5769e2d20d5">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">freetensor::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>ast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2318d60c8c228271327668df47785fc7" name="a2318d60c8c228271327668df47785fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2318d60c8c228271327668df47785fc7">&#9670;&nbsp;</a></span>Schedule() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">freetensor::Schedule::Schedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a37ef938b9a97cc35d911120950648c55" name="a37ef938b9a97cc35d911120950648c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ef938b9a97cc35d911120950648c55">&#9670;&nbsp;</a></span>asMatMul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::asMatMul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Transform nested loops to be a external call to a matrix multiplication</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td><a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop cannot be transformed to be a matrix multiplication </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac235b9b664543453d977094741cd31a7" name="ac235b9b664543453d977094741cd31a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac235b9b664543453d977094741cd31a7">&#9670;&nbsp;</a></span>ast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> freetensor::Schedule::ast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>: The statements being transformed, without a function signature </dd></dl>

</div>
</div>
<a id="af6c1cee0944a78f2662996607cf4ffe0" name="af6c1cee0944a78f2662996607cf4ffe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c1cee0944a78f2662996607cf4ffe0">&#9670;&nbsp;</a></span>autoFuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoFuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >(Experimental) Automatically fuse consecutive loops using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab49e422d97c96d24081406de659e121" name="aab49e422d97c96d24081406de659e121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab49e422d97c96d24081406de659e121">&#9670;&nbsp;</a></span>autoParallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoParallelize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >(Experimental) Automatically parallelize some loops using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c73e1f8cd59b196aa495c56fb141d8f" name="a9c73e1f8cd59b196aa495c56fb141d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c73e1f8cd59b196aa495c56fb141d8f">&#9670;&nbsp;</a></span>autoSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoSchedule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >(Experimental) Automatic scheduling using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb4eeb733444a7566604e4f19f657b07" name="aeb4eeb733444a7566604e4f19f657b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4eeb733444a7566604e4f19f657b07">&#9670;&nbsp;</a></span>autoSetMemType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoSetMemType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >(Experimental) Automatically set memory types using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f5c6509535b6636e718d7e3fdbc267f" name="a7f5c6509535b6636e718d7e3fdbc267f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5c6509535b6636e718d7e3fdbc267f">&#9670;&nbsp;</a></span>autoUnroll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoUnroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >(Experimental) Automatically unroll loops using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f6e8a418824aeaf48e5966d9046e8b4" name="a7f6e8a418824aeaf48e5966d9046e8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6e8a418824aeaf48e5966d9046e8b4">&#9670;&nbsp;</a></span>autoUseLib()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::autoUseLib </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1Target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >(Experimental) Automatically use external libs using some heuristics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>: <a class="el" href="classfreetensor_1_1Target.html">Target</a> architecture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb236565d0d590d7f4ee357d7b06911d" name="adb236565d0d590d7f4ee357d7b06911d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb236565d0d590d7f4ee357d7b06911d">&#9670;&nbsp;</a></span>blend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::blend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Unroll a loop and interleave statements from each iteration</p>
<p >E.g.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0 to 2 {</div>
<div class="line">  f(i);</div>
<div class="line">  g(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p >will be transformed to be</p>
<div class="fragment"><div class="line">f(0);</div>
<div class="line">f(1);</div>
<div class="line">g(0);</div>
<div class="line">g(1);</div>
</div><!-- fragment --><p >Virtual threads in TVM can be implemented via blend</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop being transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop is not found, the loop length is not a constant, or the dependencies cannot be solved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcb75fe9ab13e88589e3eeb6de82a854" name="adcb75fe9ab13e88589e3eeb6de82a854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb75fe9ab13e88589e3eeb6de82a854">&#9670;&nbsp;</a></span>cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a>&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Cache a variable into a new local variable</p>
<p >All needed data will be filled into the cache first, then all reads and writes will be directed to the cache, and finally all needed data will be flushed from the cache</p>
<p >Note for reduction: This transformation preserves the computation order. It will transform</p>
<div class="fragment"><div class="line">a += x</div>
<div class="line">a += y</div>
</div><!-- fragment --><p >to</p>
<div class="fragment"><div class="line">a.cache = a + x + y</div>
<div class="line">a = a.cache</div>
</div><!-- fragment --><p >If you need a "real" cache for reduction, which reorders the computation, use <code>cache_reduction</code> instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement or block (e.g. an If or a For) to be modified </td></tr>
    <tr><td class="paramname">var</td><td>: name of the variable to be cached </td></tr>
    <tr><td class="paramname">mtype</td><td>: where to cache </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the <a class="el" href="classfreetensor_1_1ID.html">ID</a> or name is not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: (<a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that fills the cache, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that flushes from the cache, name of the cache variable, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef node of the cache variable) </dd></dl>

</div>
</div>
<a id="a6e3c690de5bdcec52d0dbacf9d1b2a2d" name="a6e3c690de5bdcec52d0dbacf9d1b2a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3c690de5bdcec52d0dbacf9d1b2a2d">&#9670;&nbsp;</a></span>cacheReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a>, std::string, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::cacheReduction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a>&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Perform local reductions (e.g. sum) in a local variable first, and then reduce the local result to the global variable</p>
<p >E.g.</p>
<div class="fragment"><div class="line">a += x</div>
<div class="line">a += y</div>
</div><!-- fragment --><p >will be transformed to be</p>
<div class="fragment"><div class="line">a.cache = x + y</div>
<div class="line">a += a.cache</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement or block (e.g. an If or a For) to be modified </td></tr>
    <tr><td class="paramname">var</td><td>: name of the variable to be cached. Only reductions are allowed on <code>var</code> in <code>stmt</code>. Plain reads or writes are not allowed </td></tr>
    <tr><td class="paramname">mtype</td><td>: where to cache </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the <a class="el" href="classfreetensor_1_1ID.html">ID</a> or name is not found, or there are unsupported reads or writes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: (<a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that initialize the cache, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement that reduces the local result to the global result, name of the cache variable, <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef node of the cache variable) </dd></dl>

</div>
</div>
<a id="ada66a3399fdab1b6395fce9505556327" name="ada66a3399fdab1b6395fce9505556327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada66a3399fdab1b6395fce9505556327">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1Schedule.html">Schedule</a> freetensor::Schedule::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac74fa57a5be44bf722618fac5a60ce41" name="ac74fa57a5be44bf722618fac5a60ce41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74fa57a5be44bf722618fac5a60ce41">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> freetensor::Schedule::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Find a node in the current AST by <a class="el" href="classfreetensor_1_1ID.html">ID</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td><a class="el" href="classfreetensor_1_1ID.html">ID</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1daefd3692c06c2edac13d965e8c77a5" name="a1daefd3692c06c2edac13d965e8c77a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1daefd3692c06c2edac13d965e8c77a5">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> freetensor::Schedule::find </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the only one nodes in the current AST satisfying a given condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>: A callback. Return true for acceptance </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1Error.html">Error</a></td><td>: if there is more than one, or there is no node found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76a54397cf8641d194b9f5a23528d942" name="a76a54397cf8641d194b9f5a23528d942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a54397cf8641d194b9f5a23528d942">&#9670;&nbsp;</a></span>findAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt; freetensor::Schedule::findAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Find a (maybe non-existing) node in the current AST by <a class="el" href="classfreetensor_1_1ID.html">ID</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td><a class="el" href="classfreetensor_1_1ID.html">ID</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8f4e76f35b4baa793d72397fd0d919d" name="aa8f4e76f35b4baa793d72397fd0d919d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f4e76f35b4baa793d72397fd0d919d">&#9670;&nbsp;</a></span>findAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &gt; freetensor::Schedule::findAll </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="namespacefreetensor.html#a8b7e165b3601cc722c7b357347dc6de9">Stmt</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find all nodes in the current AST satisfying a given condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>: A callback. Return true for acceptance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54719c22533351b6b3ec37c73fb13652" name="a54719c22533351b6b3ec37c73fb13652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54719c22533351b6b3ec37c73fb13652">&#9670;&nbsp;</a></span>fission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">Schedule::IDMap</a>, <a class="el" href="classfreetensor_1_1Schedule.html#acf8585443368254e352dbe9e6408978a">Schedule::IDMap</a> &gt; freetensor::Schedule::fission </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#a2b0728b023b746c7fb73d4f24a6bb15e">FissionSide</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>splitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix0</em> = <code>&quot;.a&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix1</em> = <code>&quot;.b&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fission a loop into two loops each containing part of the statements, one followed by another</p>
<p >To split loop into two nested loops, use <code>split</code> instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop to be fissioned </td></tr>
    <tr><td class="paramname">side</td><td>: If <code>After</code>, <code>splitter</code> is the last statement of the first loop. If <code>Before</code>, <code>splitter</code> is the first statement of the second loop </td></tr>
    <tr><td class="paramname">splitter</td><td>: Where to fission the loop </td></tr>
    <tr><td class="paramname">suffix0</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> suffix of the statements in the first loop, default to ".a", can be "" for convenience, but cannot be the same with suffix1 </td></tr>
    <tr><td class="paramname">suffix1</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> suffix of the statements in the second loop, default to ".b", can be "" for convenience, but cannot be the same with suffix0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if any dependency cannot be resolved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: ({old <a class="el" href="classfreetensor_1_1ID.html">ID</a> -&gt; new <a class="el" href="classfreetensor_1_1ID.html">ID</a> in 1st loop}, {old <a class="el" href="classfreetensor_1_1ID.html">ID</a> -&gt; new <a class="el" href="classfreetensor_1_1ID.html">ID</a> in 2nd loop}) </dd></dl>

</div>
</div>
<a id="ad23d1f71efbc801f2cfa34ad8535ebaa" name="ad23d1f71efbc801f2cfa34ad8535ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23d1f71efbc801f2cfa34ad8535ebaa">&#9670;&nbsp;</a></span>func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacefreetensor.html#ab9c83946ad65f5faea0aea2fe24e1a6f">Func</a> freetensor::Schedule::func </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>: The function being transformed </dd></dl>

</div>
</div>
<a id="a2a8d6427f95b978b56357b01406d739c" name="a2a8d6427f95b978b56357b01406d739c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8d6427f95b978b56357b01406d739c">&#9670;&nbsp;</a></span>fuse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1ID.html">ID</a> freetensor::Schedule::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4628c70cf4624d39ceef40f517cf783" name="ad4628c70cf4624d39ceef40f517cf783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4628c70cf4624d39ceef40f517cf783">&#9670;&nbsp;</a></span>fuse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1ID.html">ID</a> freetensor::Schedule::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Fuse two directly following loops with the same length into one</p>
<p >To merge nested loops into one, use <code>merge</code> instead</p>
<p ><code>parallelize</code>, <code>unroll</code> and <code>vectorize</code> properties will be reset on the fused loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop0</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the leading loop </td></tr>
    <tr><td class="paramname">loop1</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the following loop. If omitted, it will try to find a following loop of <code>loop0</code> </td></tr>
    <tr><td class="paramname">strict</td><td>: If true, throw an error if unable to determine whether the two loops are of the same length </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the two loops are not directly following, the two loops are not of the same length, or there is any dependency cannot be resolved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the result loop </dd></dl>

</div>
</div>
<a id="a9bfc2f98d42e75a3838eaa0166b802e2" name="a9bfc2f98d42e75a3838eaa0166b802e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfc2f98d42e75a3838eaa0166b802e2">&#9670;&nbsp;</a></span>inlining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::inlining </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove a variable. When the variable is used, recompute its value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable. It can not be an I/O varible </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable cannot be completely removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af97ecfc9af49e07cfdc90f7d8fff9919" name="af97ecfc9af49e07cfdc90f7d8fff9919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97ecfc9af49e07cfdc90f7d8fff9919">&#9670;&nbsp;</a></span>logs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; freetensor::Schedule::logs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>: Logs of all schedules applied </dd></dl>

</div>
</div>
<a id="aa1a2b69d757e3277d357d76fc06c5c82" name="aa1a2b69d757e3277d357d76fc06c5c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a2b69d757e3277d357d76fc06c5c82">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1ID.html">ID</a> freetensor::Schedule::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Merge two directly nested loops into one</p>
<p >To fuse consecutive loops, use <code>fuse</code> instead</p>
<p ><code>parallelize</code>, <code>unroll</code> and <code>vectorize</code> properties will be reset on the merged loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop1,loop2</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loops to be merged, can be in any order </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loops are not directly nested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the merged loop </dd></dl>

</div>
</div>
<a id="a28085136b3ac2b360e10aa30b51a9fdb" name="a28085136b3ac2b360e10aa30b51a9fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28085136b3ac2b360e10aa30b51a9fdb">&#9670;&nbsp;</a></span>moveTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfreetensor_1_1ID.html">ID</a> freetensor::Schedule::moveTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#ac490983b87e6acdba7919a1cf57245c3">MoveToSide</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Move a statement to a new position</p>
<p >This is a composite schedule command, which is implemented with other commands</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the statement to be moved </td></tr>
    <tr><td class="paramname">side</td><td>: Whether <code>stmt</code> will be BEFORE or AFTER <code>dst @param dst : Insert</code>stmt` to be directly after this statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if there is no feasible path to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The new <a class="el" href="classfreetensor_1_1ID.html">ID</a> of stmt </dd></dl>

</div>
</div>
<a id="a09dd211db7d4944ec50c6ed69fc5ccf9" name="a09dd211db7d4944ec50c6ed69fc5ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dd211db7d4944ec50c6ed69fc5ccf9">&#9670;&nbsp;</a></span>multiLevelTiling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt; &gt; freetensor::Schedule::multiLevelTiling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfreetensor_1_1ForsWithDataReuse.html">ForsWithDataReuse</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfreetensor_1_1MultiLevelTilingAnnotation.html">MultiLevelTilingAnnotation</a> &amp;&#160;</td>
          <td class="paramname"><em>annotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1371b08ed69a961b5584db8adcbfde11" name="a1371b08ed69a961b5584db8adcbfde11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1371b08ed69a961b5584db8adcbfde11">&#9670;&nbsp;</a></span>multiLevelTilingWithFusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, int &gt; &gt; freetensor::Schedule::multiLevelTilingWithFusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfreetensor_1_1ForsWithDataReuse.html">ForsWithDataReuse</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfreetensor_1_1MultiLevelTilingAnnotation.html">MultiLevelTilingAnnotation</a> &amp;&#160;</td>
          <td class="paramname"><em>annotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfreetensor_1_1ElementWiseInfo.html">ElementWiseInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>toFuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#a000c2c313211c04f40116e7f8117d66b">TargetType</a>&#160;</td>
          <td class="paramname"><em>targetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doCacheRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dd6430725b39cc15a3aa5cad99fa2b1" name="a9dd6430725b39cc15a3aa5cad99fa2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd6430725b39cc15a3aa5cad99fa2b1">&#9670;&nbsp;</a></span>parallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::parallelize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacefreetensor.html#a6d19bf2262d0cd0af3903283c9722088">ParallelScope</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mark a loop with a parallel implementation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
    <tr><td class="paramname">parallel</td><td>: Parallel scope </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7152785074bdd363a5eb0091819b9152" name="a7152785074bdd363a5eb0091819b9152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7152785074bdd363a5eb0091819b9152">&#9670;&nbsp;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classfreetensor_1_1Reorder.html">Reorder</a> directly nested loops</p>
<p >To swap consecutive loops, use <code>swap</code> instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>: Vector of loop IDs. The requested order of the loops </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the input is invalid or there are breaking dependencies </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5acb3fd33acc0a8940fc36fe97a9a9da" name="a5acb3fd33acc0a8940fc36fe97a9a9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb3fd33acc0a8940fc36fe97a9a9da">&#9670;&nbsp;</a></span>separateTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::separateTail </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noDuplicateVarDefs</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Seperate main iterations and tail iterations of a loop</p>
<p >E.g.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0 -&gt; 3 {</div>
<div class="line">  <span class="keywordflow">for</span> j = 0 -&gt; 4 {</div>
<div class="line">     <span class="keywordflow">if</span> (i * 4 + j &lt; 10) {</div>
<div class="line">       ...</div>
<div class="line">     }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Each loop will be separated into 2 parts: the body and the tail. After simplification, the program will finally be transformed to</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> i = 0 -&gt; 2 {</div>
<div class="line">  <span class="keywordflow">for</span> j = 0 -&gt; 4 {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> j = 0 -&gt; 2 {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p >Ideally, all programs can benefit from this schedule. However, this schedule may greatly increase the program size and make the compiling time way too long. Therefore, this transformation is implemented as a schedule, which can be applied optionally. (TODO: Optionally apply this schedule to part of the program)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noDuplicateVarDefs</td><td>: If there is two VarDef nodes in two branches, it may result in doubled memory use, since different thread may go to different branch. Set this parameter to true to stop duplicating VarDef nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47648c797180e57a2c78438c4daad7b5" name="a47648c797180e57a2c78438c4daad7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47648c797180e57a2c78438c4daad7b5">&#9670;&nbsp;</a></span>setMemType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::setMemType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#af577e754b8b16f492893f80ae9d2b150">MemType</a>&#160;</td>
          <td class="paramname"><em>mtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Change where a variable is stored</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">mtype</td><td>: Where the variable should be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92a8d59c65897666a3380aa5bb887736" name="a92a8d59c65897666a3380aa5bb887736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a8d59c65897666a3380aa5bb887736">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a>, <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; freetensor::Schedule::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nparts</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Split a loop into two nested loops</p>
<p >To fission a loop into two consecutive loops, use <code>fission</code> instead</p>
<p >Two modes are provided:</p>
<ol type="1">
<li>Specify <code>factor</code> and leave <code>nparts</code> to -1. It will result in an outer loop with length <code>ceil(n / factor)</code>, and an inner loop with length <code>factor</code>, where <code>n</code> is the original loop length added by <code>shift</code>. The original iterator <code>i</code> will be transformed to <code>i0 * factor + i1</code>, where <code>i0</code> and <code>i1</code> are the iterators of the new outer and inner loops, respectively</li>
<li>Specify <code>nparts</code> and leave <code>factor</code> to -1. It will result in an outer loop with length <code>nparts</code>, and an inner loop with length <code>ceil(n / nparts)</code>, where <code>n</code> is the original loop length added by <code>shift</code>. The original iterator <code>i</code> will be transformed to <code>i0 * ceil(n / nparts) + i1</code>, where <code>i0</code> and <code>i1</code> are the iterators of the new outer and inner loops, respectively</li>
</ol>
<p >Please note that the second mode will introduce an <code>i0 * ceil(n / nparts)</code> factor into the program, which cannot be recognized by polyhedral analysis, which may hinder some following schedules. If possible, please use the first mode, and then reorder the inner and outer loops</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop to be split </td></tr>
    <tr><td class="paramname">factor</td><td>: Length of the inner loop. Set to -1 if using <code>nparts</code> </td></tr>
    <tr><td class="paramname">nparts</td><td>: Length of the outer loop. Set to -1 if using <code>factor</code> </td></tr>
    <tr><td class="paramname">shift</td><td>: Shift of iteration base. Defaults to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop is not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: (outer loop <a class="el" href="classfreetensor_1_1ID.html">ID</a>, inner loop <a class="el" href="classfreetensor_1_1ID.html">ID</a>) </dd></dl>

</div>
</div>
<a id="ade01fd2d0d808e2e6f76ee11af33c33d" name="ade01fd2d0d808e2e6f76ee11af33c33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade01fd2d0d808e2e6f76ee11af33c33d">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classfreetensor_1_1ID.html">ID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classfreetensor_1_1Swap.html">Swap</a> statements in the same block</p>
<p >To reorder nested loops, use <code>reorder</code> instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>: list of IDs of the statements </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the statements are not found or the dependencies cannot be solved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ae9bde8c67ec254ea7ea1542ef74660" name="a3ae9bde8c67ec254ea7ea1542ef74660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae9bde8c67ec254ea7ea1542ef74660">&#9670;&nbsp;</a></span>unroll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>immediate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Unroll a loop</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
    <tr><td class="paramname">immediate</td><td>: If false (by default), postpone the unroll procedure to the backend compiler, which saves scheduling time. If true, unroll the loop immediately, which may help further simplifications based on the unrolled result. If your purpose is just to fill the instruction cache, set it to false. If you are unrolling a loop that computes array indices, set it to true </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the loop is not found or length of the loop is not a constant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4afd2c54b5c306cea3ef02276278a638" name="a4afd2c54b5c306cea3ef02276278a638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afd2c54b5c306cea3ef02276278a638">&#9670;&nbsp;</a></span>varMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::varMerge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Merge two dimensions of a variable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">dim</td><td>: Merge the <code>dim</code>-th and the <code>(dim + 1)</code>-th dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0527473deeef7e00524a5aa1887c974b" name="a0527473deeef7e00524a5aa1887c974b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0527473deeef7e00524a5aa1887c974b">&#9670;&nbsp;</a></span>varReorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::varReorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classfreetensor_1_1Reorder.html">Reorder</a> the dimensions of a variable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">order</td><td>: new order of the dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable or the order is illegal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83689544088377af6145346f8046b9ee" name="a83689544088377af6145346f8046b9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83689544088377af6145346f8046b9ee">&#9670;&nbsp;</a></span>varSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::varSplit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacefreetensor.html#aa84a1eedb0880915c25c6ba5a2aa4db5">VarSplitMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nparts</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Split a dimension of a variable into two</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">def</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the VarDef statement of the specific variable </td></tr>
    <tr><td class="paramname">dim</td><td>: which dimension to be split </td></tr>
    <tr><td class="paramname">mode</td><td>: When the dimension to split is not divisible by <code>factor</code> or <code>nparts</code>, the resulting shape may become larger. In <code>FixedSize</code> mode, the actual buffer size will not be changed, and gurads will be added to prevent out-of-bound accesses. In <code>RelaxedSize</code> mode, the buffer size may increase. The <code>RelaxedSize</code> mode cannot be applied to I/O variables </td></tr>
    <tr><td class="paramname">factor</td><td>: Length of the inner (higher no.) dimension. Set to -1 if using <code>nparts</code> </td></tr>
    <tr><td class="paramname">nparts</td><td>: Length of the outer (lower no.) loop. Set to -1 if using <code>factor</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the variable or the dimension is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1d9ada77583888471a8378d400daf49" name="ac1d9ada77583888471a8378d400daf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d9ada77583888471a8378d400daf49">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freetensor::Schedule::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfreetensor_1_1ID.html">ID</a> &amp;&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="classfreetensor_1_1Vectorize.html">Vectorize</a> a loop</p>
<p >Please note that, as vectorization is different from architecture to achitecture, the scheduler may or may not postpone it to the backend compiler. The vectorization is a best-effort schedule</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>: <a class="el" href="classfreetensor_1_1ID.html">ID</a> of the loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classfreetensor_1_1InvalidSchedule.html">InvalidSchedule</a></td><td>if the <a class="el" href="classfreetensor_1_1ID.html">ID</a> or name is not found, or the dependency requirement is not met </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="schedule_8h_source.html">schedule.h</a></li>
<li>src/<a class="el" href="schedule_8cc.html">schedule.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
